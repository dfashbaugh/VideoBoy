#include <TeensyMAC.h>  //code to automtiacally retrieve MAC address from teensy
#include <SPI.h>         // SPI Communication from ethernet board
#include <Ethernet.h>         // Main ethernet library
#include <EthernetUdp.h>         // UDP library 
#include <SPIN.h>    //multi SPI Library for second hardware out

 uint64_t wholeMac = teensyMAC();
 uint8_t macArray[3] = { (wholeMac >>16), (wholeMac >>8), (wholeMac) };

#define NUM_LEDS 300
#define NUM_STRIPS 8

byte controller = 2   ;  // identifies this controller # to processing

// Enter a manual IP address for your controller
// Make your to match your local subnet settings:
IPAddress ip(192, 168, 1, 24 );

//mac address is automatically generated by real teensy mac address
byte mac[] = { 0x04, 0xE9, 0xE5, macArray[0], macArray[1], macArray[2] };

//Broadcast over network to announce controller # and IP Address. Broadcast to all (255.255.255.255) or specific receiver
IPAddress ipBroadcast(255, 255, 255, 255);



const int rst = 6;  //Shift register reset pin

const int shift2Clock = 17;  //Shift out pins for 8x Mosfet power and clock/data output enable
const int shift2Latch = 18;
const int shift2Data =  19;

byte leds[NUM_LEDS*NUM_STRIPS*3]; //8bit RGB Storage Array

byte brightLevel[NUM_LEDS*NUM_STRIPS]; //per pixel brightness Storage Array
uint16_t leds13[NUM_LEDS*NUM_STRIPS*3];  //Upsampled brightness array taken from 13 bit gamma curve
uint16_t maxColor; //Variable to store brightest color per pixel for setting pixel brightness


byte pack8[8]; // data pack for parallel SPI send
byte outR[8];
byte outG[8];
byte outB[8];
byte outBright[8];

byte gammaMode = 1;



const byte Gamma8 [256] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,
1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 11, 11, 
11, 12, 12, 13, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26,
27, 28, 28, 29, 30, 31, 31, 32, 33, 33, 34, 35, 36, 36, 37, 38, 39, 40, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50,
51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 69, 70, 71, 72, 73, 74, 76, 77, 78, 79, 80, 82, 83,
84, 85, 87, 88, 89, 91, 92, 93, 95, 96, 97, 99, 100, 101, 103, 104, 106, 107, 109, 110, 112, 113, 115, 116, 118, 119, 
121, 122, 124, 125, 127, 129, 130, 132, 133, 135, 137, 138, 140, 142, 144, 145, 147, 149, 151, 152, 154, 156, 158, 160, 
161, 163, 165, 167, 169, 171, 173, 175, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 197, 199, 201, 203, 205, 207,
209, 211, 213, 216, 218, 220, 222, 224, 227, 229, 231, 233, 236, 238, 240, 243, 245, 247, 250, 252, 255};

const uint16_t Gamma13 [256] = {0, 0, 0, 0, 0, 0, 0, 1, 1, 2, 3, 4, 5, 6, 7, 8, 10, 11, 13, 15, 17, 19, 22, 24, 27, 30, 32, 36, 
39, 42, 46, 50, 54, 58, 62, 67, 71, 76, 81, 87, 92, 98, 104, 110, 116, 122, 129, 136, 143, 150, 158, 166, 174, 182, 190,
198, 207, 216, 226, 235, 245, 255, 265, 275, 286, 297, 308, 319, 331, 343, 355, 367, 379, 392, 405, 419, 432, 446, 460, 
474, 489, 504, 519, 534, 549, 565, 581, 598, 615, 632, 649, 666, 684, 702, 720, 739, 757, 776, 796, 815, 835, 856, 876,
897, 918, 939, 961, 983, 1005, 1028, 1050, 1073, 1097, 1120, 1144, 1169, 1193, 1218, 1243, 1269, 1294, 1320, 1347, 1373,
1400, 1428, 1455, 1483, 1511, 1540, 1569, 1598, 1627, 1657, 1687, 1717, 1748, 1779, 1810, 1842, 1874, 1906, 1939, 1972,
2005, 2039, 2073, 2107, 2141, 2176, 2212, 2247, 2283, 2319, 2356, 2393, 2430, 2468, 2506, 2544, 2582, 2621, 2661, 2700, 
2740, 2780, 2821, 2862, 2903, 2945, 2987, 3029, 3072, 3115, 3158, 3202, 3246, 3291, 3335, 3381, 3426, 3472, 3518, 3565, 
3612, 3659, 3707, 3755, 3803, 3852, 3901, 3950, 4000, 4050, 4101, 4152, 4203, 4255, 4307, 4359, 4412, 4465, 4519, 4573, 
4627, 4681, 4736, 4792, 4847, 4904, 4960, 5017, 5074, 5132, 5190, 5248, 5307, 5366, 5426, 5486, 5546, 5607, 5668, 5729, 
5791, 5853, 5916, 5979, 6042, 6106, 6170, 6235, 6300, 6365, 6431, 6497, 6564, 6631, 6698, 6766, 6834, 6903, 6972, 7041,
7111, 7181, 7251, 7322, 7394, 7466, 7538, 7610, 7683, 7757, 7830, 7905};




unsigned int localPort = 8888;      // local ports to listen on and send to
unsigned int ProcessingPort = 6000;   //These Must match Processing Sketch

const int headerBytes=5;   // Non pixel data bytes expected from processing sketch

// buffers for receiving and sending data
byte packetBuffer[2048];  // buffer to hold incoming packet,


bool strip1received = false;  //store whether all strips have been received for each frame
bool strip2received = false;
bool strip3received = false;
bool strip4received = false;
bool strip5received = false;
bool strip6received = false;
bool strip7received = false;
bool strip8received = false;


// Start UDP instance
EthernetUDP Udp;



long sendTimer=0; // testing timers
long receiveTimer=0;
long testTimer=0;
long showTimer=0;
long functionTimer=0;

byte stripsEnabled;
byte enableLastSent;


void setup() {



 
SPI1.setSCK(20);
SPI1.setMOSI(21);
SPI1.begin();
SPI1.beginTransaction(SPISettings(12000000, LSBFIRST, SPI_MODE0));
  
pinMode(9, OUTPUT);  //reset for starting W5200
digitalWrite(9, LOW);
delay(50);
digitalWrite(9, HIGH);

pinMode(10, OUTPUT);  //select for W5200
digitalWrite(10, LOW);



pinMode (shift2Data, OUTPUT); 
digitalWrite(shift2Data, LOW);

pinMode (shift2Clock, OUTPUT);
digitalWrite(shift2Clock, LOW); 

pinMode (shift2Latch, OUTPUT);  
digitalWrite(shift2Latch, LOW);  

//start with all strips off..

stripEnable(0x00);

//send strips to power on..
stripEnable(B11111111);


pinMode(rst, OUTPUT);
digitalWrite(rst, HIGH);
digitalWrite(rst, LOW);  //start with shift register clear, probably unneccesary
 
  
     pinMode(23, OUTPUT); //Select HIGH for spi out on VideoBoy board, LOW selects OCTOWS2811Output
digitalWrite(23, HIGH);


     pinMode(22, OUTPUT); 
digitalWrite(22, HIGH); // Select spi data/clock swap: Normal HIGH, alt LOW

  
  // start the Ethernet and UDP:
  Ethernet.begin(mac, ip);
  Udp.begin(localPort);


  SPI1show813();  //start with all pixels black
  
}

void loop() {

 
  //testTimer=millis(); //loop length testing timer

  
  
  // if there's data available, read a packet
  int packetSize = Udp.parsePacket();
  if (packetSize) {Udp.read(packetBuffer, packetSize); 

if(packetBuffer[0]==101 && packetBuffer[2] == controller) {   //if command mode is 100 extract uncompressed pixel data  
   
  if(packetBuffer[3]==0 && strip1received == false)
  {  strip1received = true; stripsEnabled |= (packetBuffer[4] <<7); setColors();  }

  if(packetBuffer[3]==1 && strip2received == false)
  {  strip2received = true; stripsEnabled |= (packetBuffer[4] <<6); setColors(); }
  
  if(packetBuffer[3]==2 && strip3received == false)
  {  strip3received = true; stripsEnabled |= (packetBuffer[4] <<5); setColors(); }

  if(packetBuffer[3]==3 && strip4received == false)
  {  strip4received = true; stripsEnabled |= (packetBuffer[4] <<4); setColors();  }

  if(packetBuffer[3]==4 && strip5received == false)
  {  strip5received = true; stripsEnabled |= (packetBuffer[4] <<3); setColors();  }

  if(packetBuffer[3]==5 && strip6received == false)
  {  strip6received = true; stripsEnabled |= (packetBuffer[4] <<2); setColors();  }

  if(packetBuffer[3]==6 && strip7received == false)
  {  strip7received = true; stripsEnabled |= (packetBuffer[4] <<1); setColors();  }

  if(packetBuffer[3]==7 && strip8received == false)
  {  strip8received = true; stripsEnabled |= (packetBuffer[4] ); setColors();  }
  
} 
   
}

  if ( strip1received == true && strip2received  == true  && strip3received == true && strip4received == true
        && strip5received == true && strip6received  == true  && strip7received == true && strip8received == true)
  
    {


receiveTimer=millis();

 //digitalWrite(rst, HIGH);
//digitalWrite(rst, LOW);

Serial.println( stripsEnabled, BIN );

if(enableLastSent!=stripsEnabled)
stripEnable(stripsEnabled);


functionTimer=millis();

     if(gammaMode==0) {SPI1show8();}
     if(gammaMode==1) {SPI1show813();}
 
 //Serial.print("function length mS = "); 
 //Serial.println(millis()-functionTimer); 
      
enableLastSent=stripsEnabled;
stripsEnabled=0; 

    strip1received = false; strip2received = false; strip3received = false; strip4received = false;
    strip5received = false; strip6received = false; strip7received = false; strip8received = false;

  //Serial.print("video frame mS = "); 
  //Serial.println(millis()-showTimer);
  
                   showTimer=millis();
                   
                   }



 // blackout if no video frames received for 3 sec

 if(millis()-receiveTimer>3000){
  
  for(int i=0;i<(NUM_LEDS*NUM_STRIPS*3);i++) 
   { leds13[i]=0; }

 SPI1show813();

//if using mosfets, turn all strips off, also disable data outputs
stripEnable(0x00); 
enableLastSent=0x00; 
//tell function that enables have been turned off
 }



 
  

    // send controller # and local IP data to IP address and port specified once a second
 if(millis()-sendTimer>1000){
   
    Udp.beginPacket(ipBroadcast, ProcessingPort);
   
   Udp.write(controller);
   Udp.write(ip[0]);
   Udp.write(ip[1]);
   Udp.write(ip[2]);
   Udp.write(ip[3]);
    Udp.endPacket();
   // Serial.println("sent controller #");
    sendTimer=millis();}

}



